%USAGE: [Pinc Pdec] = BS_sync(hs, atype, aparams)
%
%   Returns the bootstrapped p values
%   Surrogates are generated by shifting the second spectrum by a random
%   amount of half the length of the data segment
%
%   hs:         the hilber transforms of the data
%   atype:      the type of analysis that is being done
%   aparams:    options

function [Pinc Pdec] = BS_sync(z0, hs, atype, aparams)

%z0 = get_sync_matrix(hs, atype, aparams);
nchan = length(z0);
nsurr = aparams.ana.nsurr;

pinc = zeros(nchan, nchan);
pdec = pinc;
z = zeros(nchan, nchan);


parfor i=1:nsurr
    z(:,:,i) = get_sync_matrix(hs, atype, aparams, 1);
end

for i=1:nsurr
    ind = find(z(:,:,i) > z0);
    pinc(ind) = pinc(ind) + 1;
    
    ind = find(z0 > z(:,:,i));
    pdec(ind) = pdec(ind) + 1;
end

Pinc = (1+pinc)./(nsurr+1);
Pdec = (1+pdec)./(nsurr+1);

function [syncm] = get_sync_matrix(hs, atype, aparams, ps)
if nargin < 4; ps = 0; end;

[nchan npoints] = size(hs);
syncm = zeros(nchan, nchan);
for i=1:nchan
    for j=i+1:nchan
        if (~ps)
            syncm(j,i) = stat(hs(i,:), hs(j,:), atype, aparams);
        else
            % phase shift the data
            sshift = floor(0.5*rand*npoints)+1;
            newh = [hs(j,sshift:end) hs(j, 1:sshift-1)];
            syncm(j,i) = stat(hs(i,:), newh, atype, aparams);
        end
    end
end

function [z] = stat(h1, h2, type, aparams)
switch type
    case 'pc'
        z = phase_coherence(h1, h2);
    case 'acorr'
        z = acorr(h1, h2);
    case 'pl'
        z = pl(h1, h2,aparams.pl.bins, aparams.pl.probbins, aparams.pl.steps);
    case 'ic'
        z = imag_coherence(h1, h2);
    case 'corr'
        z = aec(h1, h2);
    case 'coh'
        z = coherence_nogpu(h1, h2);
    case 'pli'
        z = pli(h1, h2);
    case 'wpli'
        z = wpli(h1, h2);
end

function [z] = get_sync_matrix_gpu(hs, atype, aparams, nsurr)
[nchan, npoints] = size(hs);
z = zeros(nchan, nchan, nsurr);
ghs = gpuArray(hs);
syncm = gpuArray(zeros(nchan, nchan));

for i=1:nsurr
    display(sprintf('Surrogate %d', i));
    for j=1:nchan
        for k=i+1:nchan
            sshift = floor(0.5*rand*npoints)+1;
            gnewh = [ghs(k,sshift:end) ghs(k, 1:sshift-1)];
            pdiff = angle(hs(j,:)) - angle(gnewh);
            a1 = abs(hs(j,:));
            a2 = abs(gnewh);
            switch atype
                case 'pc'
                    ssum = sum(sin(pdiff));
                    csum = sum(cos(pdiff));
                    R = sqrt((ssum/npoints)^2 + (csum/npoints)^2);
                case 'pl'
                    % Not implemented in GPU for the moment
                    R = 0;
                    %z = pl(h1, h2,aparams.pl.bins, aparams.pl.probbins, aparams.pl.steps);
                case 'ic'
                    R = mean(a1.*a2.*sin(pdiff))/sqrt(mean(a1.^2)*mean(a2.^2));
                case 'corr'
                    x1diff = x1-mean(a1);
                    x2diff = x2-mean(a2);
                    R = sum(x1diff.*x2diff)/sqrt(sum(x1diff.^2)*sum(x2diff.^2));
                case 'coh'
                    cross_spec = a1.*a2.*exp(1i*pdiff);
                    R = mean(abs(cross_spec./sqrt((mean(r1.^2)*mean(r2.^2)))));
                case 'pli'
                    plindex = 0;
                    for m=1:npoints
                        if (pdiff(m) < 0)
                            plindex = plindex-1;
                        elseif (pdiff(m) > 0)
                            plindex = plindex + 1;
                        end 
                    end
                    R = plindex/npoints;
            end
            syncm(k,j) = R;
        end
    end
    z(:,:,i) = gather(syncm);
end


